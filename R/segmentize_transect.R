# Generated by fusen: do not edit by hand


#' Segmenter les transects
#'
#' @param x Fichier sf Polygon ou Linestring. Les transects qu'ils faut dÃ©couper en segments 
#' @param length_m Numeric. Longueur des segments

#' @param to Type de fichier desire en sortie
#'
#' @importFrom sf st_geometry st_multilinestring st_sfc st_coordinates st_set_geometry st_cast st_crs st_geometry_type st_segmentize st_length
#'
#' @return Le fichier sf avec les segments
#' @export


#' @examples
#' # TO DO 
segmentize_transect <- function(x, length_m, to = "MULTILINESTRING") {
  
  x <- st_segmentize(x, dfMaxLength=units::set_units(length_m, "metres"))
  
  ggg <- st_geometry(x)
  
  if (!unique(st_geometry_type(ggg)) %in% c("POLYGON", "LINESTRING")) {
    stop("Input should be  LINESTRING or POLYGON")
  }
  for (k in 1:length(st_geometry(ggg))) {
    sub <- ggg[k]
    geom <- lapply(
      1:(length(st_coordinates(sub)[, 1]) - 1),
      function(i)
        rbind(
          as.numeric(st_coordinates(sub)[i, 1:2]),
          as.numeric(st_coordinates(sub)[i + 1, 1:2])
        )
    ) %>%
      st_multilinestring() %>%
      st_sfc()
    
    if (k == 1) {
      endgeom <- geom
    }
    else {
      endgeom <- rbind(endgeom, geom)
    }
  }
  endgeom <- endgeom %>% st_sfc(crs = st_crs(x))
  if (class(x)[1] == "sf") {
    endgeom <- st_set_geometry(x, endgeom)
  }
  if (to == "LINESTRING") {
    endgeom <- endgeom %>% st_cast("LINESTRING")
  }
  
  endgeom$Effort <- st_length(endgeom)
  
  # Name segment
  endgeom$Sample.Label <- NA
  
  # loop over the transect IDs
  for(this_transect in unique(endgeom$transect)){
    # how many segments in this transect?
    n_segs <- nrow(subset(endgeom, transect==this_transect))
    # generate the n_segs labels that we need
    endgeom$Sample.Label[endgeom$transect==this_transect] <- paste(this_transect,1:n_segs, sep="-")}
  
  return(endgeom)
}

