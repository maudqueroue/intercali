---
title: "flat_detection.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.
-->

# Detection fonction

```{r function-detection}

#' Fonction de détection
#'
#' @param dist_obj Dataframe avec les donnees de distance
#' @param key character. Forme de la fonction de détetcion "hn" ou "unif"
#' @param esw_km numeric. Effective strip width (km). Utile que pour la demi normale, sinon NA. Par défaut NA.
#' @param strip_prob numeric. Le parametre de la loi uniforme. Par défaut NA.
#' @param truncation_m numeric. A partir de quelle distance aucun individu ne peut être détecté.
#'
#' @importFrom dplyr mutate
#' @importFrom stats rbinom
#'
#' @return dataframe. Le tableau des distances avec en plus l'ajout de colonnes de porbabilité de détection et de la détection 1/0 calculée.
#' @export


detection <- function(dist_obj, key, esw_km = NA, strip_prob = NA, truncation_m) {
  
  if(key == 'hn'){
    sigma <- scale_hn(esw = esw_km)
    dist_obj <- dist_obj %>%
      mutate(proba = exp(-(distance_km)^2 / (2 * sigma * sigma))) %>%
      mutate(detected = rbinom(nrow(dist_obj), size = 1, prob = proba))
    
    dist_obj$detected[dist_obj$distance_m > truncation_m] <- 0
  }
  
  if(key == 'unif'){
    dist_obj <- dist_obj %>%
      mutate(proba = strip_prob) %>%
      mutate(detected = rbinom(nrow(dist_obj), size = 1, prob = proba))
    
    dist_obj$detected[dist_obj$distance_m > truncation_m] <- 0
    dist_obj$proba[dist_obj$distance_m > truncation_m] <- 0
  }
  
  return(dist_obj)
  
}
```

```{r examples-detection}

```

```{r tests-detection}

```

# Fonction provenant de pelastan

```{r function-esw_hn}

#' Esw_hn
#'
#' @param sigma Numeric. Le sigma d'une fonction demi normale
#' @param w Numeric. Je ne sais pas
#'
#' @importFrom stats pnorm dnorm
#'
#' @return Numeric. La valeur de esw associée au sigma.
#' @export

esw_hn <- function(sigma, w = +Inf){
  esw <- (pnorm(w, 0, sigma) - 0.5) / dnorm(0, 0, sigma)
  return(esw)
  }

```

```{r examples-esw_hn}

```

```{r tests-esw_hn}

```

# Fonction provenant de palastan !

```{r function-scale_hn}

#' Scale hn
#'
#' @param esw Numeric. effctive strip width
#' @param lower Numeric. lower
#' @param upper Numeric. upper
#' @param w Numeric. Je ne sais pas
#'
#' @importFrom stats uniroot
#'
#' @return numeric. Le sigma associé à l'esw dans le cas d'une demi normale 
#' @export


scale_hn <- function(esw, lower = 1e-3, upper = 5, w = +Inf) {
  res <- as.numeric(uniroot(function(x, ...) {esw_hn(sigma = x, w = w) - esw},
                            lower = lower,
                            upper = upper,
                            tol = 1e-8)[1])
  return(res)
}

```

```{r examples-scale_hn}

```

```{r tests-scale_hn}

```

# Plot detection
Cette fonction permet de représenter sur une carte les individus qui ont été vu par rapport aux individus qui n'ont pas été vu vus selon les transects et le processus de détection.

```{r function-plot_detect}

#' PLot detection
#'
#' @param dist_obj dataframe. Le tableau contenant les distance de chaque individu simulé au transects.
#' @param transect_obj dataframe. Le tableau renseignant sur les transects.
#' @param map_obj dataframe. La carte de densité.
#' @param title character. Le titre souhiaté pour le graphique.
#'
#' @importFrom ggplot2 ggplot geom_sf geom_point aes coord_sf scale_fill_gradientn labs theme element_text element_blank element_rect element_line theme_set theme_bw unit
#' @importFrom ggspatial annotation_scale annotation_north_arrow north_arrow_fancy_orienteering
#' @importFrom sp bbox
#' @importFrom sf as_Spatial st_sf st_union
#'
#' @return plot. Une carte mettant en évidence les individus détectés.
#' @export

plot_detect <- function(dist_obj, transect_obj, map_obj, title) {

  # on veut les contours
  contour_obj <- map_obj %>%
    st_union()

  # bounding box
  xlim <- bbox(as_Spatial(contour_obj))[1, ]
  ylim <- bbox(as_Spatial(contour_obj))[2, ]

  # Plot detection
  theme_set(theme_bw(base_size = 12))
  ggplot() +
    geom_sf(data = transect_obj, color = "black") +
    geom_sf(data = contour_obj, aes(), color = "black", alpha = 0) +
    geom_point(data = dist_obj[dist_obj$detected == 0, ], aes(x = x, y = y), alpha = 0.3, shape = 20) +
    geom_point(data = dist_obj[dist_obj$detected == 1, ], aes(x = x, y = y), shape = 21, fill = "midnightblue") +
    coord_sf(xlim = xlim, ylim = ylim) +
    annotation_scale(location = "br", width_hint = 0.5) +
    annotation_north_arrow(location = "tr",
                           which_north = "true",
                           pad_x = unit(0.2, "cm"),
                           pad_y = unit(0.1, "cm"),
                           style = north_arrow_fancy_orienteering) +
    labs(title = title, caption = paste("Sightings = ", sum(dist_obj$detected), sep = " ")) +
    theme(legend.position = "bottom",
          legend.key.width = unit(0.5, "cm"),
          legend.text = element_text(size = 6),
          plot.margin = unit(c(-1,0.1,-1,0.1), "cm"),
          panel.grid = element_line(colour = "transparent"),
          plot.title = element_text(lineheight = 0.2, face = "bold"),
          axis.text = element_text(size = 10),
          strip.background = element_rect(fill = "white"),
          axis.title.x = element_blank(),
          axis.title.y = element_blank(),
          panel.background = element_rect(fill = "azure"),
          panel.border = element_rect(fill = NA))
}

```

```{r examples-plot_detect}

```

```{r tests-plot_detect}

```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_detection.Rmd",                          
               vignette_name = "Detection",
               open_vignette = FALSE,
               check = FALSE,
               overwrite = TRUE)
```
