---
title: "flat_transect.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)

```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.
-->


# Create transects

Cette fonction permet de créer des transect grâce à la fonction du package dssd. Elle permet ensuite de générer un objet sf, plus facile à manipuler.

```{r function-create_transect}

#' Create transect
#'
#' @param region_obj Formal class region object. La region creer à partir de make.region
#' @param crs Numeric.Le systeme de coordonnees geographiques 
#' @param design a character variable describing the type of design. Either "random", "systematic", "eszigzag" (equal-spaced zigzag), "eszigzagcom" (equal spaced zigzag with complementary lines) or "segmentedgrid". See details for more information. See package dssd pour information
#' @param spacing used by systematic designs, numeric value(s) to define spacing between transects. Can be a vector of values with one value per stratum.
#' @param design.angle numeric value detailing the angle of the design. Can provide multiple values relating to strata. The use of the angle varies with design, it can be either the angle of the grid of points, the angle of lines or the design axis for the zigzag design. See details. In addition, a value of -1 will cause a random design angle to be generated. 
#' @param line.length Numeric. the total line length you desire. 
#' @param truncation A single numeric value describing the longest distance at which an object may be observed. 
#'
#' @importFrom dssd make.design generate.transects
#' @importFrom sf st_cast st_sf
#' @importFrom dplyr select
#'
#' @return sf object. Les transects crees
#' @export

create_transect <- function(region_obj, crs, design, spacing = numeric(0), design.angle, line.length = numeric(0), truncation) {
  
  zigzag.design <- make.design(region = region_obj,
                               design = design,
                               spacing = spacing,
                               edge.protocol = "minus",
                               design.angle = design.angle,
                               line.length = line.length,
                               bounding.shape = "convex.hull",
                               truncation = truncation)
  
  z.survey <- generate.transects(zigzag.design)
  
  x <- z.survey@samplers %>%
    as.data.frame() %>%
    select("transect","geometry") %>%
    st_sf(crs = crs) %>%
    st_cast("LINESTRING")
  
  return(x)
}

```

```{r examples-create_transect}
# TO DO 
```

```{r tests-create_transect}
# TO DO 
```


# Crop transects

Cette fonction permet de créer des transect grâce à la fonction du package dssd. Elle permet ensuite de générer un objet sf, plus facile à manipuler.

```{r function-crop_transect}

#' Crop transect
#'
#' @param transect_obj Dataframe. Les transects.
#' @param map_obj Dataframe. Le tableau avec les données de la carte
#'
#' @importFrom sf st_union st_intersection
#'
#' @return Dataframe. Les transects croppés sur la taille de la grille.
#' @export

crop_transect <- function(transect_obj, map_obj) {
  
  contour_obj <- map_obj %>%
    st_union()
  
  
  transect_out <- transect_obj %>%
    st_intersection(contour_obj)
  
  return(transect_out)
  
}

```

```{r examples-crop_transect}
# TO DO 
```

```{r tests-crop_transect}
# TO DO 
```


# Segmenter les transects

La fonction n'est pas de moi. Elle nécessite que je travaille un peu dessus. Mais elle est tellement pratique que je la mets disponible ici.

```{r function-segmentize_transect}

#' Segmenter les transects
#'
#' @param transect_obj Fichier sf Polygon ou Linestring. Les transects qu'ils faut découper en segments 
#' @param length_m Numeric. Longueur des segments

#' @param to Type de fichier desire en sortie
#'
#' @importFrom sf st_geometry st_multilinestring st_sfc st_coordinates st_set_geometry st_cast st_crs st_geometry_type st_segmentize st_length
#'
#' @return Le fichier sf avec les segments
#' @export


segmentize_transect <- function(transect_obj, length_m, to = "MULTILINESTRING") {
  
  transect_obj <- st_segmentize(transect_obj, dfMaxLength=units::set_units(length_m, "metres"))
  
  ggg <- st_geometry(transect_obj)
  
  if (!unique(st_geometry_type(ggg)) %in% c("POLYGON", "LINESTRING")) {
    stop("Input should be  LINESTRING or POLYGON")
  }
  for (k in 1:length(st_geometry(ggg))) {
    sub <- ggg[k]
    geom <- lapply(
      1:(length(st_coordinates(sub)[, 1]) - 1),
      function(i)
        rbind(
          as.numeric(st_coordinates(sub)[i, 1:2]),
          as.numeric(st_coordinates(sub)[i + 1, 1:2])
        )
    ) %>%
      st_multilinestring() %>%
      st_sfc()
    
    if (k == 1) {
      endgeom <- geom
    }
    else {
      endgeom <- rbind(endgeom, geom)
    }
  }
  endgeom <- endgeom %>% st_sfc(crs = st_crs(transect_obj))
  if (class(transect_obj)[1] == "sf") {
    endgeom <- st_set_geometry(transect_obj, endgeom)
  }
  if (to == "LINESTRING") {
    endgeom <- endgeom %>% st_cast("LINESTRING")
  }
  
  endgeom$Effort <- st_length(endgeom)
  
  # Name segment
  endgeom$Sample.Label <- NA
  
  # loop over the transect IDs
  for(this_transect in unique(endgeom$transect)){
    # how many segments in this transect?
    n_segs <- nrow(subset(endgeom, transect==this_transect))
    # generate the n_segs labels that we need
    endgeom$Sample.Label[endgeom$transect==this_transect] <- paste(this_transect,1:n_segs, sep="-")}
  
  return(endgeom)
}

```

```{r examples-segmentize_transect}
# TO DO 
```

```{r tests-segmentize_transect}
# TO DO 
```


# Zone controlée
```{r function-get_monitored_area}

#' Obetnir l'aire de la zone d'étude qui est controlée par les transects
#'
#' @param transect_obj dataframe. Les transects 
#' @param map_obj dataframe. La carte de densité
#' @param truncation_m numeric. La distance à laquelle on ne peut plus observer d'animaux. En m.
#'
#' @importFrom sf st_sf st_buffer st_union st_intersection st_area
#'
#' @return numeric. L'aire de la surface d'étude monitorée en m
#' @export


get_monitored_area <- function(transect_obj, map_obj, truncation_m) {
  
  contour_obj <- map_obj %>%
    st_union()
  
  out <- transect_obj %>%
    st_buffer(dist = truncation_m, endCapStyle = 'FLAT') %>%
    st_union %>%
    st_intersection(contour_obj) %>%
    st_area()
  
  return(out)
  
}
```

```{r examples-get_monitored_area}
# TO DO 
```

```{r tests-get_monitored_area}
# TO DO 
```

# Plot transects

Cette fonction permet de visualiser les transects.

```{r function-plot_transect}

#' Plot transect
#'
#' @param transect_obj dataframe. Le tableau de données avec les transects.
#' @param map_obj dataframe. La carte avec les densités
#' @param crs numeric. Le systeme de coordonnees utilisé.
#' @param ifsegs TRUE/FALSE. Est-ce que les transects sont des segments ?
#'
#' @importFrom ggplot2 ggplot geom_sf aes coord_sf scale_colour_manual geom_point theme element_text theme_set theme_bw unit element_rect element_line
#' @importFrom ggspatial annotation_scale annotation_north_arrow north_arrow_fancy_orienteering
#' @importFrom sp bbox
#' @importFrom sf as_Spatial st_sf
#' @importFrom grDevices rainbow
#'
#' @return plot. La carte de la region avec les transects.
#' @export

plot_transects <- function(transect_obj, map_obj, crs, ifsegs) {
  
  # on veut les contours
  contour_obj <- map_obj %>%
    st_union()
  
  # bounding box
  xlim <- bbox(as_Spatial(contour_obj))[1, ]
  ylim <- bbox(as_Spatial(contour_obj))[2, ]
  
  theme_set(theme_bw())
  
  if(ifsegs == FALSE){
    plot <- ggplot() +
      geom_sf(data = contour_obj, aes(), color = "black", alpha = 0) +
      
      geom_sf(data = transect_obj, aes(), color = "black") +
      coord_sf(xlim = xlim, ylim = ylim) +
      annotation_scale(location = "br", width_hint = 0.5) +
      annotation_north_arrow(location = "tr",
                             which_north = "true",
                             pad_x = unit(0.2, "cm"),
                             pad_y = unit(0.1, "cm"),
                             style = north_arrow_fancy_orienteering) +
      theme(legend.position = "none",
            panel.grid = element_line(colour = "transparent"),
            plot.title = element_text(lineheight = 0.8, face = "bold"),
            axis.text = element_text(size = 6),
            strip.background = element_rect(fill = "white"),
            axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            panel.background = element_rect(fill = "azure"),
            panel.border = element_rect(fill = NA))
  }
  
  if(ifsegs == TRUE){
    pal <- rainbow(nrow(transect_obj), s=.6, v=.9)[sample(1:nrow(transect_obj),nrow(transect_obj))]
    
    plot <-  ggplot() +
      geom_sf(data = contour_obj, aes(), color = "black", alpha = 0) +
      geom_sf(data = transect_obj, aes(colour = Sample.Label)) +
      coord_sf(xlim = xlim, ylim = ylim) +
      annotation_scale(location = "br", width_hint = 0.5) +
      annotation_north_arrow(location = "tr",
                             which_north = "true",
                             pad_x = unit(0.2, "cm"),
                             pad_y = unit(0.1, "cm"),
                             style = north_arrow_fancy_orienteering) +
      scale_colour_manual(values=pal) +
      theme(legend.position = "none",
            panel.grid = element_line(colour = "transparent"),
            plot.title = element_text(lineheight = 0.8, face = "bold"),
            axis.text = element_text(size = 6),
            strip.background = element_rect(fill = "white"),
            axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            panel.background = element_rect(fill = "azure"),
            panel.border = element_rect(fill = NA))
  }
  
  return(plot)
}


```

```{r examples-plot_transect}
# TO DO 
```

```{r tests-plot_transect}
# TO DO 
```

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_transect.Rmd", 
               vignette_name = "Transect",
               open_vignette = FALSE,
               check = FALSE,
               overwrite = TRUE)
```
